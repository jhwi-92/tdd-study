# 테스트 코드 작성 순서
## 초반에 복잡한 테스트부터 시작하면 안 되는 이유
한 번에 구현해야 하는 코드가 많아짐 → 본인도 모르게 버그를 만들고 버그를 잡기 위해 많은 시간을 허비하게 됨 → 집중력이 떨어져 흐름이 자주 끊김

## 구현하기 쉬운 테스트부터 시작하기
가장 구현하기 쉬운 경우부터 시작하면 빠르게 테스트를 통과시킬 수 있다. <br>
<br>암호 강도 측정 예에서는 다음과 같은 단계로 진행하면 테스트 코드를 잘 작성할 수 있다. 
1. 단순히 값 리턴하기
   * `모든 조건을 충족`하는 경우
     * `STRONG`을 리턴한다.
   * `모든 조건을 충족하지 않는` 경우
     * `WEAK`를 리턴한다.

2. `STRONG`과 `WEAK`에 맞는 예시 추가하기
3. 한 규칙만 충족하는 경우를 추가한다.
   * 한 규칙을 충족하는지 여부를 검사해서 `WEAK`를 리턴하면 된다. 
4. 한 규칙만 충족하는 경우를 또 추가한다.
    * 앞에서 한 규칙은 이미 통과했으므로 한 규칙을 더 추가하면 두 규칙을 충족하게 된다.
    * 규칙을 통과했다면 규칙을 2개 충족하는 것이므로 `NORMAL`을 리턴하면 된다. 
5. 규칙의 상세 내용을 작성한다. 
    * 대문자 포함 여부를 검사하거나 숫자 포함 여부를 검사하는 것보다는 8글자 이상인지 검사하는 게 쉬워 글자 길이를 먼저 테스트 한다. 
      * 길이만 8글자 미만이고 나머지 규칙은 충족하는 암호의 강도는 `보통`
        <br>또는
      * 길이가 8글자 이상이고 나머지 규칙은 충족하지 않은 암호의 강도는 `약함`
<br><br>

과 같은 순으로 하나씩 테스트를 통과 시켜가며 `점진적`으로 구현해간다. 

## 예외 상황을 먼저 테스트해야 하는 이유
* 예외 상황에 따른 `if-else` 구조가 미리 만들어지기 때문에 많은 코드를 완성한 뒤에 예외 상황을 반영할 때보다 코드 구조가 덜 바뀐다. 
* 예외 상황을 처리하지 않아 발생하는 버그를 줄여준다. 

## 완급 조절
TDD를 처음 접할 때는 다음 단계에 따라 TDD를 익혀보자.
1. 정해진 값을 리턴
2. 값 비교를 이용해서 정해진 값을 리던
3. 다양한 테스트를 추가하면서 구현을 일반화

## 지속적인 리팩토링
* 테스트 통과 후 적당한 후보가 보이면 리팩토링 진행
  * 코드 중복은 대표적인 리팩토링 대상
  * 코드가 길어지면 메서드 추출과 같은 기법을 사용해서 메서드 이름으로 코드의 의미 표현
  * 코드 가독성이 높아짐
    * 빠르게 코드 분석 가능
    * 코드 변경의 어려움이 줄어 유지보수에 도움<br
<br>

### 테스트 대상 코드의 리팩토링 시점
* 상수→변수로 바꾸거나 변수 이름을 변경하는 것과 같은 작은 리팩토링은 발견하면 바로 실행한다.
* 메서드 추출과 같이 메서드의 구조에 영향을 주는 리팩토링은 큰 틀에서 구현 흐름이 눈에 들어오기 시작한 뒤에 진행한다. 

# 테스트 작성 순서 연습
매달 비용을 지불해야 사용할 수 있는 유료 서비스가 있다고 해보자. 이 서비스는 다음 규칙에 따라 서비스 만료일을 결정한다. 
* 서비스를 사용하려면 매달 1만 원을 선불로 납부한다. 납부일 기준으로 한 달 뒤가 서비스 만료일이 된다.
* 2개월 이상 요금을 납부할 수 있다.
* 10만 원을 납부하면 서비스를 1년 제공한다. 
<br>

해당 기능을 TDD로 구현한다면 가장 먼저 테스트 클래스의 `이름`을 정해보자. <br>
우리는 `만료일을 계산`하는 기능을 구현할 것이기에 만료일(expiry) date + 계산하다(Calculator)를 더해 ExpiryDateCalculator로 정한다. 

## 테스트할 목록 정리하기
1. 테스트할 내용 목록을 정리한다. 
   * 1만 원 납부하면 한 달 뒤가 만료일
   * 달의 마지막 날에 납부하면 다음달 마지막 날이 만료일
   * 2만 원 납부하면 2개월 뒤가 만료일
   * 3만 원 납부하면 3개월 뒤가 만료일
   * 10만 원 납부하면 1년 뒤가 만료일
2. 어떤 테스트가 구현이 쉬울지, 또는 어떤 테스트가 예외적인지 상상해본다. 
    * 구현의 난이도나 구조를 검토하면 다음 테스트 선택할 때 도움이 된다. 
3. 테스트 과정에서 새로운 테스트 사례를 발견하면 목록에 추가해서 놓치지 않도록 한다. 
    * 지라나 트렐로와 같은 시스템을 사용하면 테스트 사례를 하위 작업으로 등록해서 테스트 통과 여부를 추적할 수 있다. 
    * 새로 발견한 테스트 사례를 실패하는 테스트로 등록하는 것도 새로운 사례를 놓치지 않는 방법이 될 수 있다. 
4. 테스트 목록을 적었다고 해서 테스트를 한 번에 다 작성하면 안된다. 
    * 구현 초기에도 리팩토링을 마음껏 못 하게 된다. 
5. `테스트 코드 작성→테스트 통과→리팩토링`의 비교적 짧은 리듬을 반복한다.
    * 다루는 범위가 작고 개발 주기도 짧으므로 개발 집중력도 높아진다.
6. 범위가 큰 리팩토링은 진행하지 말고 테스트를 통과시키는 데 집중한다. 
    * 대신 다음 할 일 목록에 추가해서 놓치지 않고 진행할 수 있게 한다. 
    * 범위가 크면 리팩토링에 실패할 수 있으므로 진행 전 커밋을 하자. 
## 시작이 안 될 때는 단언부터 고민
테스트 코드 작성이 잘 되지 않는다면 `검증하는 코드`부터 작성하기 시작하면 도움이 된다. <br>

예를 들어 만료일 계산 기능의 경우 만료일을 검증하는 코드부터 작성해 보는 것이다. 

````java
@Test
void 만원_납부하면_한달_뒤가_만료일이_됨(){
    // 처음 작성하는 코드
    assertEquals(기대하는만료일,실제만료일);
}
````
<br>
먼저 만료일을 어떻게 표현할지 결정해야 한다. <br>
만료일은 날짜를 표현하는 타입인 LocalDate를 사용한다. 

````java
assertEquals(LocalDate.of(2019,8,9),실제만료일);
````

<br>
다음은 실제 만료일을 바꿀 차례다. 이 값은 만료일을 실제로 계산한 결과값을 갖는 변수로 바꿀 수 있다. 

````java
LocalDate realExpiryDate = 계산하기
assertEquals(LocalDate.of(2019,8,9),realExpiryDate);
````
<br>
이제 realExpiryDate 변수를 구하는 코드를 작성한다. 

````java
LocalDate realExpiryDate = cal.calculateExpiryDate(파라미터);
assertEquals(LocalDate.of(2019,8,9),realExpiryDate);
````
<br>
cal의 정확한 타입은 모르지만 어떤 객체의 메서드를 실행해서 계산 기능을 실행하도록 했다. <br>
이제 cal의 타입과 파라미터타입을 정해야 한다.<br>
만료일을 계산하는데 납부일과 납부액이 있어야 만료일을 계산할 수 있으므로 파라미터에는 이 두 값을 전달한다. <br>
만원을 납부했을 때 한 달 뒤가 만료일이 되는지를 테스트할 것이므로 납부일로 2019-07-09를 전달하고 납부액으로 10,000원을 전달하게 코드를 수정한다. 

````java
LocalDate realExpiryDate = cal.calculateExpiryDate(LocalDate.of(2019,7,9),10_000);
assertEquals(LocalDate.of(2019,8,9),realExpiryDate);
````
<br>
cal 타입은 간단한 만료일 계산을 뜻하는 ExpirytDateCalculator로 정해보자. 그럼 위 코드는 다음과 같이 바뀐다.

````java
ExpirytDateCalculator cal = new ExpirytDateCalculator();
LocalDate realExpiryDate = cal.calculateExpiryDate(LocalDate.of(2019,7,9),10_000);
assertEquals(LocalDate.of(2019,8,9),realExpiryDate);
````
<br>
이렇게 테스트 코드를 어떻게 작성할지 감을 못 잡겠다면 검증 코드부터 시작해보자.

## 구현이 막힌다면
TDD를 진행하다 보면 구현이 막힐 때가 있는데 이럴 땐 과감하게 코드를 지우고 미련 없이 다시 시작한다. <br>
다시 진행할 때에는 다음을 상기한다.
* 쉬운 테스트, 예외적인 테스트
* 완급 조절
